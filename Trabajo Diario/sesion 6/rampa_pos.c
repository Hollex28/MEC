#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma  platform(NXT)
#include "writeFile.c"

const string  sFileName = "data111.txt";

task main()
{
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        /// INICIALIZACIÓN DEL BUCLE DE CONTROL DE POSICIÓN
        ///////////////////////////////////////////////////////////////////////////////////////////////////

        // espacio definición obligatoria de variables
	float Pos_final=6.0*2*pi; // valor final de la referencia de posición: 6 vueltas (en radianes)
	float tfinal=10.0;	  // tiempo (en segundos) para la generación de la rampa: 10
	float refrad;		  // variable en que se calculará la referencia de posición
	float erroractual=0.0;	  // error de posición instante k
	float errorcua=0.0;	  // indice error cuadrático
	float acActual=0.0;	  // valor acción de control instante k
	float pmuestreo=0.02;	  // periodo muestreo
	long i = 0;
	long niteraciones;
	float incre;

        // espacio definición libre de variables



        // inicialización del proceso: reset encoder, fichero de datos, fin de bucle...
	nMotorEncoder[motorA] = 0;
	Delete(sFileName,nIoResult);
	createTextFile(sFileName, 30000);
        niteraciones=(int)((tfinal-2.0)/0.02); // n. de iteraciones: tiempo final (menos 2 segundo) dividido entre Ts (20 mS)
        incre=(float)(Pos_final/niteraciones); // incremento: valor final de la rampa dividivo por el n. de iteraciones



        ///////////////////////////////////////////////////////////////////////////////////////////////////
        /// PRIMER BUCLE DE CONTROL DE POSICIÓN: GENERACIÓN DE LA RAMPA
        ///////////////////////////////////////////////////////////////////////////////////////////////////

        while(i < niteraciones)  // 1ª parte de la referencia: generación de la rampa
         {

          // generación de la referencia de posición.
          refrad=incre*i;


	  // obtener el valor de la posición actual (en radianes). MODIFICAR!!!
          posradactual=


	  // calcular del error de posición. MODIFICAR!!!
          erroractual=refrad-posradactual;


	  // calcular la acción de control. MODIFICAR!!!
	  acActual=


	  // saturar la acción de control para que esté en el rango -100 .. +100


	  // proporcionar la acción de control


	  // actualización de los valores del error y de la acción de control en instantes anteriores


	  // cálculo de los índices de error cuadrático
	  errorcua=errorcua+erroractual*erroractual;


          // escritura de los valores significativos en el fichero de datos de salida
	  writeFloatNumber(refrad);
	  writeFloatNumber(posradactual);
	  writeFloatNumber(acActual);
	  writeFloatNumber(errorcua);
	  writeNewLine();

          // verificar el periodo de muestreo de 20mS


         i++;
      }


       ///////////////////////////////////////////////////////////////////////////////////////////////////
       /// SEGUNDO BUCLE DE CONTROL DE POSICIÓN: MANTENER REF POSICIÓN CONSTANTE DURANTE 2 SEG.
       ///////////////////////////////////////////////////////////////////////////////////////////////////

	i=0;
        niteraciones=(int)((2.0)/0.02); // n. de iteraciones: 2 segundos dividido entre Ts (20 mS)
	while(i < niteraciones)
        {

    	// obtener el valor de la posición actual (en radianes). MODIFICAR
        posradactual=


	// calcular el error de posición en función de Pos_final. MODIFICAR
        erroractual=

	// calcular la acción de control. MODIFICAR
	acActual=

	// saturar la acción de control para que esté en el rango -100 .. +100


	// proporcionar la acción de control


	// actualización de los valores del error y de la acción de control en instantes anteriores


	// calcular de los índices de error cuadrático y absoluto
	errorcua=errorcua+erroractual*erroractual;

	// escritura de los valores significativos en el fichero de datos
	writeFloatNumber(Pos_final);
	writeFloatNumber(posradactual);
	writeFloatNumber(acActual);
	writeFloatNumber(errorcua);
	writeNewLine();

        // verificar el periodo de muestreo de 20mS



        i++;
    }

    closeWriteTextFile();

}
