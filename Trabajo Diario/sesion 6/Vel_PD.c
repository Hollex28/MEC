#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma  platform(NXT)
#include "writeFile.c"

const string  sFileName = "Control_Vel_PD.txt";

task main()
{
          ///////////////////////////////////////////////////////////////////////////////////////////////////
          /// INICIALIZACI�N DEL BUCLE DE CONTROL DE VELOCIDAD
          ///////////////////////////////////////////////////////////////////////////////////////////////////

          // espacion definici�n obligatoria de variables
	        float Ref_vel=1.0*2*PI;  // referencia de velocidad angular: (1*2*pi)/s (1 vuelta cada seg.)
	        float tfinal=10.0;       // tiempo de ejecucion: 10 seg.
          float acActual=0.0;	   // valor acci�n de control instante k
          float erroractual=0.0;   // error de posici�n instante k
  	      float errorcua=0.0;	   // indice error cuadr�tico
	        float pmuestreo=0.02;    // periodo muestreo
          long i = 0;
	        long niteraciones;
          float Tp = 0.0696;
          float T0 = 0.0238;
          float K = 0.1445;
          float Kpd = 1.2 * (Tp / (K*T0));
          float Td = 0.5 * T0;
          float Ts = pmuestreo;


          float q0 = Kpd * ( (Ts+Td)/Ts);
          float q1 = -Kpd * (Td /Ts);

	      float erroranterior = 0;
          float posradactual;
          float velrueda;
          float posanterior;
          // espacio definici�n libre de variables



          // inicializaci�n de variables del proceso: reset encoder, fichero de datos, fin de bucle...
          nMotorEncoder[motorA] = 0;
          Delete(sFileName,nIoResult);
          createTextFile(sFileName, 30000);
          i=0;
          niteraciones=(int)(tfinal/0.02);


          ///////////////////////////////////////////////////////////////////////////////////////////////////
          /// BUCLE DE CONTROL
          ///////////////////////////////////////////////////////////////////////////////////////////////////
          while(i < niteraciones)
            {

      	     // obtener la posicion actual del motor (en rad). MODIFICAR!!!
             posradactual= (nMotorEncoder[motorA]*pi)/180;


             // se estima la velocidad del motor (rad/s) en funcion posicion actual y anterior. MODIFICAR!!!
      	     velrueda=( posradactual - posanterior) / pmuestreo;


       	     // se calcula el error de velocidad (Ref_Vel vs velrueda). MODIFICAR!!!
             erroractual=Ref_vel-velrueda;

      	     // se calcula la accion de control.MODIFICAR!!!
                acActual=q0*erroractual+q1*erroranterior;

     	     // saturar la accion de control para que este en el rango -100 .. +100
              if(acActual > 100){
                acActual = 100;
              }
              if(acActual < -100){
                acActual = -100;
              }

	     // proporcionar la acci�n de control
              motor[motorA] = acActual;

	     // actualizaci�n de los valores del error y de la acci�n de control en instantes anteriores
              erroranterior = erroractual;
              posanterior = posradactual;
             // c�lculo de los �ndices de error cuadr�tico y absoluto
	            errorcua=errorcua+erroractual*erroractual;

             // escritura de los valores significativos en el fichero de datos de salida
              writeFloatNumber(Ref_vel);
              writeFloatNumber(velrueda);
              writeFloatNumber(acActual);
              writeFloatNumber(errorcua);
              writeNewLine();
             // verificar el perido de muestreo de 20mS
              wait1Msec(20);
              i++;
          }
          closeWriteTextFile();
}
