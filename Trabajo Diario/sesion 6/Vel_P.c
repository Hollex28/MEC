#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma  platform(NXT)
#include "writeFile.c"

const string  sFileName = "Control_Vel_P.txt";

task main()
{
          ///////////////////////////////////////////////////////////////////////////////////////////////////
          /// INICIALIZACIÓN DEL BUCLE DE CONTROL DE VELOCIDAD
          ///////////////////////////////////////////////////////////////////////////////////////////////////

          // espacion definición obligatoria de variables
	        float Ref_vel=1.0*2*PI;  // referencia de velocidad angular: (1*2*pi)/s (1 vuelta cada seg.)
	        float tfinal=10.0;       // tiempo de ejecucion: 10 seg.
          float acActual=0.0;	   // valor acción de control instante k
          float erroractual=0.0;   // error de posición instante k
  	      float errorcua=0.0;	   // indice error cuadrático
	        float pmuestreo=0.02;    // periodo muestreo
          long i = 0;
	        long niteraciones;
          float Tp = 0.0696;
          float T0 = 0.0238;
          float K = 0.1445;
          float Kp = Tp / (K*T0);

          float q0 = Kp;

          float posradactual;
          float velrueda;
          float posanterior;
          // espacio definición libre de variables



          // inicialización de variables del proceso: reset encoder, fichero de datos, fin de bucle...
          nMotorEncoder[motorA] = 0;
          Delete(sFileName,nIoResult);
          createTextFile(sFileName, 30000);
          i=0;
          niteraciones=(int)(tfinal/0.02);


          ///////////////////////////////////////////////////////////////////////////////////////////////////
          /// BUCLE DE CONTROL
          ///////////////////////////////////////////////////////////////////////////////////////////////////
          while(i < niteraciones)
            {

      	     // obtener la posicion actual del motor (en rad). MODIFICAR!!!
             posradactual= (nMotorEncoder[motorA]*pi)/180;


             // se estima la velocidad del motor (rad/s) en funcion posicion actual y anterior. MODIFICAR!!!
      	     velrueda=( posradactual - posanterior) / pmuestreo;


       	     // se calcula el error de velocidad (Ref_Vel vs velrueda). MODIFICAR!!!
            erroractual=Ref_vel-velrueda;

      	     // se calcula la accion de control.MODIFICAR!!!
      	     acActual=q0*erroractual;


     	     // saturar la accion de control para que este en el rango -100 .. +100
    if(acActual > 100){
	    acActual = 100;
	  }
	  if(acActual < -100){
	    acActual = -100;
	  }

	     // proporcionar la acción de control
    motor[motorA] = acActual;

	     // actualización de los valores del error y de la acción de control en instantes anteriores

        posanterior = posradactual;
             // cálculo de los índices de error cuadrático y absoluto
	     errorcua=errorcua+erroractual*erroractual;

             // escritura de los valores significativos en el fichero de datos de salida
	     writeFloatNumber(Ref_vel);
	     writeFloatNumber(velrueda);
	     writeFloatNumber(acActual);
             writeFloatNumber(errorcua);
	     writeNewLine();

             // verificar el perido de muestreo de 20mS
            wait1Msec(20);

             i++;
          }

          closeWriteTextFile();

}
