#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma  platform(NXT)
#include "writeFile.c"

const string  sFileName = "Control_Pos_PI_v2.txt";

task main()
{
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        /// INICIALIZACIÓN DEL BUCLE DE CONTROL DE POSICIÓN
        ///////////////////////////////////////////////////////////////////////////////////////////////////

        // espacio definición obligatoria de variables
	float Pos_final=6.0*2*pi; // valor final de la referencia de posición: 6 vueltas (en radianes)
	float tfinal=10.0;	  // tiempo (en segundos) para la generación de la rampa: 10
	float refrad;		  // variable en que se calculará la referencia de posición
	float erroractual=0.0;	  // error de posición instante k
	float errorcua=0.0;	  // indice error cuadrático
	float acActual=0.0;	  // valor acción de control instante k
	float pmuestreo=0.02;	  // periodo muestreo
	long i = 0;
	long niteraciones;
	float incre;
	float Kc=715;
	float Tc=0.18;
	float posradactual;

	float Kpi = Kc*0.45;
	float Ts = pmuestreo;
	float Ti=(2*Tc)/1.2;

	float q0 = Kpi*((Ts+Ti)/Ts);
	float q1 = -Kpi *(Ti/Ts);

	float erroranterior = 0;
	float accionanterior = 0;

        // espacio definición libre de variables



        // inicialización del proceso: reset encoder, fichero de datos, fin de bucle...
	  		nMotorEncoder[motorA] = 0;
	  		Delete(sFileName,nIoResult);
	      createTextFile(sFileName, 30000);
        niteraciones=(int)((tfinal-2.0)/0.02); // n. de iteraciones: tiempo final (menos 2 segundo) dividido entre Ts (20 mS)
        incre=(float)(Pos_final/niteraciones); // incremento: valor final de la rampa dividivo por el n. de iteraciones



        ///////////////////////////////////////////////////////////////////////////////////////////////////
        /// PRIMER BUCLE DE CONTROL DE POSICIÓN: GENERACIÓN DE LA RAMPA
        ///////////////////////////////////////////////////////////////////////////////////////////////////

        while(i < niteraciones)  // 1ª parte de la referencia: generación de la rampa
        {


          // generación de la referencia de posición.
          refrad=incre*i;


	  // obtener el valor de la posición actual (en radianes). MODIFICAR!!!
          posradactual=(nMotorEncoder[motorA]*pi)/180;


	  // calcular del error de posición. MODIFICAR!!!
          erroractual=refrad-posradactual;


	  // calcular la acción de control. MODIFICAR!!!
	  acActual=q0*erroractual+q1*erroranterior+accionanterior;


	  // saturar la acción de control para que esté en el rango -100 .. +100
    if(acActual > 100){
	    acActual = 100;
	  }
	  if(acActual < -100){
	    acActual = -100;
	  }

	  // proporcionar la acción de control
    motor[motorA] = acActual;

	  // actualización de los valores del error y de la acción de control en instantes anteriores
    accionanterior = acActual;
    erroranterior = erroractual;
	  // cálculo de los índices de error cuadrático
	  errorcua=errorcua+erroractual*erroractual;


          // escritura de los valores significativos en el fichero de datos de salida
	  writeFloatNumber(refrad);
	  writeFloatNumber(posradactual);
	  writeFloatNumber(acActual);
	  writeFloatNumber(errorcua);
	  writeNewLine();

          // verificar el periodo de muestreo de 20mS
        wait1Msec(20);

         i++;
      }


       ///////////////////////////////////////////////////////////////////////////////////////////////////
       /// SEGUNDO BUCLE DE CONTROL DE POSICIÓN: MANTENER REF POSICIÓN CONSTANTE DURANTE 2 SEG.
       ///////////////////////////////////////////////////////////////////////////////////////////////////

	i=0;
	erroranterior = 0;
	accionanterior = 0;
        niteraciones=(int)((2.0)/0.02); // n. de iteraciones: 2 segundos dividido entre Ts (20 mS)
	while(i < niteraciones)
        {

    	// obtener el valor de la posición actual (en radianes). MODIFICAR
          posradactual=(nMotorEncoder[motorA]*pi)/180;


	// calcular el error de posición en función de Pos_final. MODIFICAR
        erroractual=Pos_final-posradactual;

	// calcular la acción de control. MODIFICAR
	  acActual=q0*erroractual+q1*erroranterior+accionanterior;

	// saturar la acción de control para que esté en el rango -100 .. +100
    if(acActual > 100){
	    acActual = 100;
	  }
	  if(acActual < -100){
	    acActual = -100;
	  }

	// proporcionar la acción de control
    motor[motorA] = acActual;

	// actualización de los valores del error y de la acción de control en instantes anteriores
erroranterior = erroractual;
accionanterior = acActual;
	// calcular de los índices de error cuadrático y absoluto
	errorcua=errorcua+erroractual*erroractual;

	// escritura de los valores significativos en el fichero de datos
	writeFloatNumber(Pos_final);
	writeFloatNumber(posradactual);
	writeFloatNumber(acActual);
	writeFloatNumber(errorcua);
	writeNewLine();

        // verificar el periodo de muestreo de 20mS

  wait1Msec(20);

        i++;
    }

    closeWriteTextFile();

}
