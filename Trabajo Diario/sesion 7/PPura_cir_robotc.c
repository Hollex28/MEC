#pragma config(Motor,  motorA,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorB,          ,              tmotorNormal, openLoop, encoder)
#pragma config(Motor,  motorC,          ,              tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma  platform(NXT)
#include "writeFile3.c"

#define PI 3.14159265358979
#define TRUE 1
#define FALSE 0

const string  sFileNamePlot = "PPcua.txt"; //nombre fichero datos

//TYPES DEFINITION
typedef struct {
  float x;
  float y;
} point;

task main()
{
  long i = 0, indice=0;

  long ruedaAant=0;
  long ruedaAnue=0;
  long ruedaBant=0;
  long ruedaBnue=0;

  float vel_ang_d, vel_ang_i;
  float vel_lin_d, vel_lin_i;

  float error_vel_r, error_vel_l;
  float velLin_robot, velAng_robot;
  float increX=0.0, LA=1.0;

  float ex=0.0, ey=0.0, errorcua=0.0; //error cuadratico movimiento robot

  float Kmp=9.4276;           // ganancia proporcional control dinamico ruedas robot

  float radiorueda=0.028;     // el radio de la rueda son 28 mm

  nMotorEncoder[motorA] = 0; // reseteamos el encoder de la rueda derecha
  nMotorEncoder[motorB] = 0; // reseteamos el encoder de la rueda izquierda


  float min_dist, aux, ka, rho;
  float Dis_fija = 0.080;

  Delete(sFileNamePlot,nIoResult);
  createTextFile(sFileNamePlot, 30000);

  ///////////////////////////////////
  //INICIALIZACION PERSECUCION PURA//
  ///////////////////////////////////
  //Posición inicial
  float theta = (1/4) * PI;
  float x = 0.40, y = 0.1;
  float xob = 0, yob = 0;

  float dist_x, dist_y;

  float center_x = 0.0, center_y = 0.0;

  float V = 0.300; //velocidad de avance del robot
  float left_wheel_speed_ref, right_wheel_speed_ref;
  float wref_l, wref_r;
  float control_action_l = 0, control_action_r = 0;

  float pulse2rad = (2*PI)/360;

  float b = 0.110/2;
  float wheel_radius_left = 0.028;  //radio rueda izqda.
  float wheel_radius_right = 0.028; //radio rueda dcha.

  float Ts = 0.050; //periodo de muestreo

  long current_point = 0;
  long num_points = 0;
  long j = 0;

  float orbit_radius=0.0, itheta=0.0;

  point t[220]; //vector para almacenar la trayectoria

  //Reset valores variables
  xob = x;
  yob = y;


  num_points = 200;
  center_x = 0.000;
  center_y = 0.000;
  orbit_radius = 0.5;

  //generación trayectoria circular
  for (i=0; i<num_points; i++) {
    itheta = (((float)i) /((float)num_points))*2*PI;
    t[i].x = center_x + cos( itheta )*orbit_radius;
    t[i].y = center_y + sin( itheta )*orbit_radius;
  }
  ///////////////////////////////////////
  //FIN INICIALIZACION PERSECUCION PURA//
  ///////////////////////////////////////


  while(indice < 400) //podría ser infinito while(1), pero se deja en 400 iteraciones
  {
    ClearTimer(T1);

    // obtener valor de encoders para ver cuanto se ha movido
    ruedaAnue=nMotorEncoder[motorA];
    ruedaBnue=nMotorEncoder[motorB];

    // calculo velocidades angulares (rad/s) de las ruedas
    vel_ang_d=pulse2rad*(ruedaAnue-ruedaAant)/Ts;
    vel_ang_i=pulse2rad*(ruedaBnue-ruedaBant)/Ts;

    // calculo velocidades lineales (m/s) de ruedas: v = w*radio
    vel_lin_d=vel_ang_d*radiorueda;
    vel_lin_i=vel_ang_i*radiorueda;

    // calculo velocidad lineal del robot
    velLin_robot=

    // calculo velocidad angular del robot
    velAng_robot=

    // calculo posicion X-Y y la orientacion del robot
    x=x+velLin_robot*Ts*cos(theta);
    y=y+velLin_robot*Ts*sin(theta);
    theta=theta+velAng_robot*Ts;


    //////////////////////////////
    //ALGORITMO PERSECUCION PURA//
    //////////////////////////////
    //Reset distancia minima a un valor suficientemente grande
    min_dist = 9999999999;

    //Recorremos la mitad de la trayectoria que sigue al ultimo punto seleccionado
    for (i = current_point; i < (current_point + ((int)(num_points/2))); i++) {

      dist_x = t[i%num_points].x - x;
      dist_y = t[i%num_points].y - y;
      aux = sqrt((dist_x*dist_x) + (dist_y*dist_y));

      if (aux > Dis_fija) {
        if (aux < min_dist) {
          min_dist = aux;
          current_point = i%num_points;
        }
      }
    }

    //Establecemos la referencia
    xob = t[current_point].x;
    yob = t[current_point].y;

    //Calculo error lateral increX y la curvatura
	  increX=

  	LA=

  	rho=


    //Calculo cinemática inversa robot
    left_wheel_speed_ref =
    right_wheel_speed_ref =

    //Calculo referencia velocidad angular para control dinamico
    wref_l = left_wheel_speed_ref/wheel_radius_left;
    wref_r = right_wheel_speed_ref/wheel_radius_right;

    //Calculo error velocidad angular de las ruedas
    error_vel_r=wref_r-vel_ang_d;
    error_vel_l=wref_l-vel_ang_i;

    //Calculo acción de control de los motores
    control_action_l=error_vel_l*Kmp;
    control_action_r=error_vel_r*Kmp;

    // calculo indice integral error cuadratico
		ex=xob-x;
		ey=xob-y;
		errorcua=errorcua+sqrt(ex*ex+ey*ey);

    //Grabar en fichero datos ejecución
    writeFloatNumber(xob);
    writeFloatNumber(yob);
    writeFloatNumber(x);
    writeFloatNumber(y);
    writeFloatNumber(errorcua);
    writeFloatNumber(control_action_r);
    writeFloatNumber(control_action_l);
    writeNewLine();


    //Saturación acciones de control
    if (control_action_l > 100) {
      control_action_l = 100;
    }
    if (control_action_l < -100) {
      control_action_l = -100;
    }
    if (control_action_r > 100) {
      control_action_r = 100;
    }
    if (control_action_r < -100) {
      control_action_r = -100;
    }


    motor[motorA] = control_action_r;
    motor[motorB] = control_action_l;

    //actualizamos valores variables anteriores
    ruedaAant=ruedaAnue;
    ruedaBant=ruedaBnue;
    indice=indice+1;

    //Verificar periodo de muestreo
    while(time1(T1)<50)
    {
      wait1Msec(50 - time1(T1));
    }
  }
  closeWriteTextFile();
}
